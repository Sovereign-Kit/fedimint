<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module implements fedimints custom atomic broadcast abstraction. A such, it is responsible for ordering serialized items in the form of byte vectors. The Broadcast is able to recover from a crash at any time via a backup that it maintains in the servers fedimint_core::db::Database. In Addition, it stores the history of accepted items in the form of signed session outcomes in the database as well in order to catch up fellow guardians which have been offline for a prolonged period of time."><title>fedimint_server::atomic_broadcast - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-2c208a72533b4dd0.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="fedimint_server" data-themes="" data-resource-suffix="" data-rustdoc-version="1.79.0-nightly (ccfcd950b 2024-04-15)" data-channel="nightly" data-search-js="search-ffac13a0df2b1870.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-e32f0c247825364d.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-c97aec732c613ca4.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-09095024cf37855e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../fedimint_server/index.html">fedimint_server</a><span class="version">0.4.0-alpha</span></h2></div><h2 class="location"><a href="#">Module atomic_broadcast</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section><h2><a href="../index.html">In crate fedimint_server</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../fedimint_server/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings">Settings</a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">fedimint_server</a>::<wbr><a class="mod" href="#">atomic_broadcast</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/fedimint_server/atomic_broadcast/mod.rs.html#1-122">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module implements fedimints custom atomic broadcast abstraction. A
such, it is responsible for ordering serialized items in the form of byte
vectors. The Broadcast is able to recover from a crash at any time via a
backup that it maintains in the servers [fedimint_core::db::Database]. In
Addition, it stores the history of accepted items in the form of
signed session outcomes in the database as well in order to catch up fellow
guardians which have been offline for a prolonged period of time.</p>
<p>Though the broadcast depends on [fedimint_core] for [fedimint_core::PeerId],
[fedimint_core::encoding::Encodable] and [fedimint_core::db::Database]
it implements no consensus logic specific to Fedimint, to which we will
refer as Fedimint Consensus going forward. To the broadcast a consensus item
is merely a vector of bytes without any further structure.</p>
<h2 id="the-journey-of-a-consensusitem"><a class="doc-anchor" href="#the-journey-of-a-consensusitem">§</a>The journey of a ConsensusItem</h2>
<p>Let us sketch the journey of an [fedimint_core::epoch::ConsensusItem] into a
signed session outcome.</p>
<ul>
<li>The node which wants to order the item calls consensus_encode to serialize
it and sends the resulting serialization to its running atomic broadcast
instance via the mempool item sender.</li>
<li>Every 250ms the broadcasts currently running session instance creates a
new batch from its mempool and attaches it to a unit in the form of a
UnitData::Batch. The size of a batch and therefore the size of a
serialization is limited to 10kB.</li>
<li>The unit is then included in a <a href="struct.Message.html" title="struct fedimint_server::atomic_broadcast::Message">Message</a> and send to the network layer via
the outgoing message sender.</li>
<li>The network layer receives the message, serializes it via consensus_encode
and sends it to its peers, which in turn deserialize it via
consensus_decode and relay it to their broadcast instance via their
incoming message sender.</li>
<li>The unit is added to the local subgraph of a common directed acyclic graph
of units generated cooperatively by all peers for every session.</li>
<li>As the local subgraph grows the units within it are ordered and so are the
attached batches. As soon as it is ordered the broadcast instances unpacks
our batch sends the serialization to Fedimint Consensus in the form of an
ordered item.</li>
<li>Fedimint Consensus then deserializes the item and either accepts the item
bases on its current consensus state or discards it otherwise. Fedimint
Consensus transmits its decision to its broadcast instance via the
decision_sender and processes the next item.</li>
<li>Assuming our item has been accepted the broadcast instance appends its
deserialization is added to the session outcome corresponding to the
current session.</li>
<li>Roughly every five minutes the session completes. Then the broadcast
creates a threshold signature for the session outcome’s header and saves
both in the form of a signed session outcome in the local database.</li>
</ul>
<h2 id="interplay-with-fedimint-consensus"><a class="doc-anchor" href="#interplay-with-fedimint-consensus">§</a>Interplay with Fedimint Consensus</h2>
<p>As an item is only recorded in a session outcome if it has been accepted the
decision has to be consisted for all correct nodes in order for them to
create identical session outcomes for every session. We introduce this
complexity in order to prevent a critical DOS vector were a client submits
conflicting items, like double spending an ecash note for example, to
different peers. If Fedimint Consensus would not be able to discard the
conflicting items in such a way that they do not become part of the
broadcasts history all of those items would need to be maintained on disk
indefinitely.</p>
<p>Therefore it cannot be guaranteed that all broadcast instances return the
exact stream of ordered items. However, if two correct peers obtain two
ordered items from their broadcast instances they are guaranteed to be in
the same order. Furthermore, an ordered items is guaranteed to be seen by
all correct nodes if a correct peer accepts it. Those two guarantees are
sufficient to build consistent replicated state machines like Fedimint
Consensus on top of the broadcast. Such a state machine has to accept an
item if it changes the machines state and should discard it otherwise. Let
us consider the case of an ecash note being double spend by the items
A and B while one peer is offline. First, item A is ordered and all correct
peers include the note as spent in their state. Therefore they also accept
the item A. Then, item B is ordered and all correct nodes notice the double
spend and make no changes to their state. Now they can safely discard the
item B as it did not cause a state transition. When the session completes
only item A is part of the corresponding session outcome. When the offline
peer comes back online it downloads the session outcome. Therefore the
recovering peer will only see Item A but arrives at the same state as its
peers at the end of the session regardless. However, it did so by processing
one less ordered item and without realizing that a double spend had
occurred.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.Keychain"><code>pub use keychain::<a class="struct" href="keychain/struct.Keychain.html" title="struct fedimint_server::atomic_broadcast::keychain::Keychain">Keychain</a>;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="backup/index.html" title="mod fedimint_server::atomic_broadcast::backup">backup</a></div></li><li><div class="item-name"><a class="mod" href="data_provider/index.html" title="mod fedimint_server::atomic_broadcast::data_provider">data_provider</a></div></li><li><div class="item-name"><a class="mod" href="finalization_handler/index.html" title="mod fedimint_server::atomic_broadcast::finalization_handler">finalization_handler</a></div></li><li><div class="item-name"><a class="mod" href="keychain/index.html" title="mod fedimint_server::atomic_broadcast::keychain">keychain</a></div></li><li><div class="item-name"><a class="mod" href="network/index.html" title="mod fedimint_server::atomic_broadcast::network">network</a></div></li><li><div class="item-name"><a class="mod" href="spawner/index.html" title="mod fedimint_server::atomic_broadcast::spawner">spawner</a></div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Message.html" title="struct fedimint_server::atomic_broadcast::Message">Message</a></div><div class="desc docblock-short">The majority of these messages need to be delivered to the intended
<a href="enum.Recipient.html" title="enum fedimint_server::atomic_broadcast::Recipient">Recipient</a> in order for the broadcast to make progress. However, the
broadcast does not assume a reliable network layer and implements all
necessary retry logic. Therefore, the caller can discard a message
immediately if its intended recipient is offline.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Recipient.html" title="enum fedimint_server::atomic_broadcast::Recipient">Recipient</a></div><div class="desc docblock-short">This enum defines the intended destination of a <a href="struct.Message.html" title="struct fedimint_server::atomic_broadcast::Message">Message</a>.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.to_node_index.html" title="fn fedimint_server::atomic_broadcast::to_node_index">to_node_index</a></div></li><li><div class="item-name"><a class="fn" href="fn.to_peer_id.html" title="fn fedimint_server::atomic_broadcast::to_peer_id">to_peer_id</a></div></li></ul></section></div></main></body></html>